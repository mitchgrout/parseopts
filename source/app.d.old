module parseopts;

import std.traits;
import std.stdio;

struct switches {
	this(string longKey, string shortKey){
		assert(longKey.length, "Long switch name cannot be empty");
		this.longKey = longKey;
		assert(shortKey.length, "Short switch name cannot be empty");
		this.shortKey = shortKey;
	}
	
	this(string longKey){
		this(longKey, "");
	}
	
	string longKey, shortKey;
}

template parseOpts(T) if(is(T == struct)) {
	T parseOpts(string[] args) {
		import std.conv : to;
		T res;

		for(int i = 0; i < args.length; i++){
			if(args[i][0] != '-') continue;
			switch(args[i]){

				mixin(genCases);

				default: assert(0, "No such symbol: " ~ args[i]); 
			}	
		}
		return res;
	}

	string genCases(){
		string res;
		foreach(member; __traits(allMembers, T)){
			res ~= `case `;
			auto attrs = getUDAs!(mixin("T."~member), switches);
			static if(attrs.length){
				switches s = attrs[0];
				res ~= `"`~s.longKey~`", "`~s.shortKey~`":`;
			} else {
				res ~= `"--`~member~`":`;
			}
			res ~= "\n";
res ~= `static if(is(typeof(T.`~member~`) == bool)) {
		res.`~member~` = true; 
	} else { 
		res.`~member~` = args[++i].to!(typeof(T.` ~ member ~ `)); 
	} 
	break;` ~ "\n"; 
		}
		return res;
	}
}

unittest {
	Test1 res = parseOpts!Test1(["--verbosity", "7", "--daemon", "-p", "/some/path/home/"]);
	assert(res.verbosity == 7);
	assert(res.daemon == true);
	assert(res.path == "/some/path/home/");

}

struct Test1 {
	//Defaults to single switch: --verbosity
	int verbosity;

	//Two switches: --daemon, -d
	@switches("--daemon", "-d")
	bool daemon;

	//Two switches: --path, -p
	@switches("--path", "-p")
	string path;
}
